package me.minoneer.bukkit.bookexploit;

import net.md_5.bungee.api.ChatColor;
import net.md_5.bungee.api.chat.ClickEvent;
import org.bukkit.World;
import org.bukkit.configuration.Configuration;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.plugin.Plugin;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

public final class ConfigHandler {
    private static final String PATH_FILTER_CONTENT = "filter_content";
    private static final String PATH_CHECK_CREATION = "check_actions.book_creation";
    private static final String PATH_CHECK_READING = "check_actions.book_reading";
    private static final String PATH_PERMITTED_CONTENT = "permitted_content";
    private static final String PATH_WORLD_WHITELIST = "world_whitelist";
    private static final String PATH_PLAYER_MESSAGE = "player_message";

    private final Plugin plugin;
    private final Logger logger;
    private final FileConfiguration config;

    private Set<ClickEvent.Action> filterActions;
    private boolean checkCreation;
    private boolean checkReading;
    private List<String> worldWhitelist;
    private WildcardMatcher permittedContent;
    private String playerMessage;

    public ConfigHandler(@NotNull final Plugin plugin) {
        this.plugin = plugin;
        this.logger = plugin.getLogger();
        this.config = loadConfig();
        loadData();
    }

    private FileConfiguration loadConfig() {
        plugin.saveDefaultConfig();
        plugin.reloadConfig();
        final FileConfiguration config = plugin.getConfig();
        config.options().copyDefaults(true);
        try (Reader reader = new InputStreamReader(Objects.requireNonNull(plugin.getResource("config.yml")))) {
            final Configuration defaults = YamlConfiguration.loadConfiguration(reader);
            config.setDefaults(defaults);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Unable to load default config values", e);
        }
        plugin.saveConfig();
        plugin.reloadConfig();
        return plugin.getConfig();
    }

    private void loadData() {
        final ConfigurationSection filterContent = Objects.requireNonNull(
                config.getConfigurationSection(PATH_FILTER_CONTENT),
                "Missing configuration section " + PATH_FILTER_CONTENT
        );
        this.filterActions = EnumSet.copyOf(
                Arrays.stream(ClickEvent.Action.values())
                        .filter(action -> filterContent.getBoolean(action.name().toLowerCase(Locale.US), false))
                        .collect(Collectors.toSet())
        );

        this.checkCreation = config.getBoolean(PATH_CHECK_CREATION, true);
        this.checkReading = config.getBoolean(PATH_CHECK_READING, true);
        List<String> worldWhiteList = config.getStringList(PATH_WORLD_WHITELIST);
        this.worldWhitelist = worldWhiteList.isEmpty() ? null : worldWhiteList;

        this.permittedContent = new WildcardMatcher(config.getStringList(PATH_PERMITTED_CONTENT));

        final String rawMessage = config.getString(PATH_PLAYER_MESSAGE);
        if (rawMessage != null && !rawMessage.trim().isEmpty()) {
            this.playerMessage = ChatColor.translateAlternateColorCodes('&', rawMessage);
        } else {
            this.playerMessage = null;
        }
    }

    @NotNull
    public Set<ClickEvent.Action> getFilterActions() {
        return filterActions;
    }

    public boolean isWorldDisabled(World world) {
        return this.worldWhitelist != null && !this.worldWhitelist.contains(world.getName());
    }

    public boolean isContentPermitted(String content) {
        return permittedContent.matches(content);
    }

    @Nullable
    public String getPlayerMessage() {
        return playerMessage;
    }

    public boolean checkAction(FilterAction action) {
        switch (action) {
            case READ:
                return checkReading;
            case CREATE:
                return checkCreation;
            default:
                return true;
        }
    }
}
